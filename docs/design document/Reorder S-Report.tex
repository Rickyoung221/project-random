\documentclass[12pt, a4paper]{article}

\makeatletter
\begingroup\endlinechar=-1\relax
       \everyeof{\noexpand}%
       \edef\x{\endgroup\def\noexpand\homepath{%
         \@@input|"kpsewhich --var-value=HOME" }}\x
\makeatother

\def\overleafhome{/tmp}% change as appropriate
\usepackage{fontspec}
\ifx\homepath\overleafhome
\setmonofont{CONSOLA.TTF}[
BoldFont=CONSOLAB.ttf,
ItalicFont=CONSOLAI.ttf,
BoldItalicFont=CONSOLAZ.ttf
]
\else
\setmonofont{Consolas}
\fi

\usepackage[onehalfspacing]{setspace}
\usepackage{subfigure}
\parskip=1mm plus 1pt
\usepackage{indentfirst}
\usepackage{forest}
\usepackage[export]{adjustbox}
\usetikzlibrary{arrows.meta, %提供Stealth[]箭头类型
angles} %提供angle pic
	\forestset{
	tree angle/.style={
		% !表示开始相对引用。u是父节点，n是下一个兄弟节点。他们都是short-form step。
		% pic {angle}: draw a small picture of type angle.
		% angle是来自\usetikzlibrary{angles}。
		% The angle pic draws an angle between the two lines BA and BC, where A, B, and C are three coordinates.
		tikz={\path () coordinate (A) -- (!u) 
			coordinate (B) -- (!n) 
			coordinate (C) pic [draw, angle radius=#1] {angle};}
	},
	tree angle/.default=5mm
}

\usepackage[section]{placeins}

\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{makeidx}
\usepackage{hyperref}
\hypersetup{
unicode=true,          % non-Latin characters in Acrobat’s bookmarks
pdftitle={},    % title   
%pdfauthor={爱让一切都对了},     % author   
%pdfcreator={爱让一切都对了},
%pdfproducer={OpenOffice.org 3.3},
breaklinks=true,
colorlinks=true,       % false: boxed links; ture: colored links
linkcolor=blue,          % color of internal links   
citecolor=blue,        % color of links to bibliography  
filecolor=magenta,      % color of file links   
urlcolor=cyan,           % color of external links  
}
\usepackage{xcolor}

\usepackage{url}
\def\UrlBreaks{\do\A\do\B\do\C\do\D\do\E\do\F\do\G\do\H\do\I\do\J\do\K\do\L\do\M\do\N\do\O\do\P\do\Q\do\R\do\S\do\T\do\U\do\V\do\W\do\X\do\Y\do\Z\do\[\do\\\do\]\do\^\do\_\do\`\do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j\do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t\do\u\do\v\do\w\do\x\do\y\do\z\do\0\do\1\do\2\do\3\do\4\do\5\do\6\do\7\do\8\do\9\do\.\do\@\do\\\do\/\do\!\do\_\do\|\do\;\do\>\do\]\do\)\do\,\do\?\do\'\do+\do\=\do\#}

\usepackage{listings}
\lstset{
%  %行号
%  %numbers=left,
%  %背景框
%  %framexleftmargin=10mm,
%  %frame=none,
%  %背景色
%  %backgroundcolor=\color[rgb]{1,1,0.76},
%  %样式
  keywordstyle=\color{blue}\bfseries,
%  identifierstyle=\bf,
%  numberstyle=\color[RGB]{0,192,192}, %行号的样式
  commentstyle=\it\color[RGB]{0,96,96},
  stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},
%  %显示空格
%  %showstringspaces=false,
  basicstyle=\ttfamily\footnotesize, %修正大写字母间距过小
  columns=flexible, %修正大写字母间距过小
  breaklines=true, %对过长的代码自动换行
%  escapechar=!,
%  morekeywords={BEGIN}
    upquote=true,
  language=python
}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\citeWeb}[3]{#1, \url{#2}, Retrieved #3.}
\title{CS 188 Security Evaluation on Team Random's Project}
\author{Weikeng Yang\\405346443 \and
Yingzhe Hu\\505366341 \and
Qiqi Gu\\604253019 \and
Dongyao Liang\\705313832 \and
Shuhua Zhan\\705190671}
\date{Team name: Random\\[2mm]February 28, 2020}

\usepackage[numbers]{natbib}
\setcitestyle{square}

\usepackage{graphicx}
\makeindex

\begin{document}

\maketitle

\tableofcontents

\section{Summary}

\index{Summary}
This report evaluates our own project, Google Play Advanced Search.

Requirement: A brief summary of your findings, including the approach(es) you took and what you learned. This should be at a high level (e.g., "Working from the design document, we decided to perform code review using the following techniques, supplemented by the following kinds of testing") and should include some conclusion about the security of the system (e.g., "Our analysis showed that the mitigations used to address security concerns in our system were effective," or "Our analysis reveals fatal security flaws that could be remediated in the following ways," or a statement of similar nature).   For evaluation of the other team’s project, remember that your goal is not to criticize their efforts, but to determine whether they achieved sufficiently secure results and to suggest improvements if they did not. 

\section{Security Evaluation Plan}

\index{Security Evaluation Plan}
Requirement: A description of your plan for the security evaluation, including steps to be taken, tools or approaches used, work assignments, and a schedule. Since it is likely that your plan required some adjustments, you should discuss the degree to which you followed your plan versus deviating from it, as well as explanations for such deviations.  

We plan to evaluate two parts of project Google Play Advanced Search, namely the source code, and the application deployed to Google Cloud, accessible via \url{https://beta.gqqnbig.me/}. We will check the security issues in the source code, and find if the server is properly protected.

When we were developing the project, we were already performing code review, ie. a team member creates pull requests (PR) for his/her changes, and an experienced team member will review the commits in the pull requests, approve the PR or request revisions. However, it is mainly Qiqi and Dongyao who review pull requests. We will ask other team members to read the code in hope that they find out something the PR reviewer missed before.

When we are doing security evaluation code review, candidate point strategies.

We will also check the security vulnerabilities of the dependencies of the project.

Our plan for the security evaluation as follow:
\begin{itemize}
    \item Security Design Review
    \item Code Review and External Packages
    \item Testing
    
Testing is one important element of our evaluation. We plan to use these testing tools:
\begin{itemize}
    \item Network sniffers
    \item \code{Nmap} as Port scanners
    \item \code{OWASP ZAP} for Web security testing 
%    \item Tools to test crypto usage
    \item Fuzz testing tools
%    \item Password crackers
%    \item Database security scanners
%    \item Mobile app security testers (MASTs)
    \item Interactive application security testing (IAST)
\end{itemize}
\end{itemize}



\section{Security Evaluation Results}

\index{Security Evaluation Results} 
Requirement: You should describe the results of your security evaluation, providing sufficient details to justify any conclusions you reach. This section should be significantly more extensive than the summary, containing a great deal more detail. If, for example, you found a dangerous race condition in the code, you should describe how you found it, what the security implications are, and suggest approaches for fixing it or ensuring that it is not exploited. 

\subsection{Security Design Review}
\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{Context_Diagram.jpeg}
\caption{Design Diagram}
\label{fig:design_diagram}
\end{figure}

Figure \ref{fig:design_diagram} is the design diagram. We evaluate the design again. By looking at the source code at a high level, we conclude the implemented project largely matches the design, with a few exceptions.

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{project-structure.png}
\caption{Project structure. \code{src} is the source code root.}
\label{fig:project-structure}
\end{figure}

The implemented project has 3 modules, well organized into a hierarchical namespace, see Figure \ref{fig:project-structure}. \code{src} is the source code root. tests is the additional module but since it's for automated tests, the addition is not a big deal.

The design diagram indicates there is a server component, but actually the django module and the scraper module both run on a server; the SQLite database is on the same server as well. Some functions, for instance \code{src/GooglePlayAdvancedSearch/DBUtils.py} are shared across modules. 

Unlike the design diagram, the implemented website talks to database, and run scraper as a standalone process. Both are found in \linebreak[4]
\code{GooglePlayAdvancedSearch\linebreak[0].django.web.Api}\footnote{All code are in namespace \code{GooglePlayAdvancedSearch}. Moveing forward, we will remove this prefix for conciseness and only say \code{django.web.Api}.}.

Moreover, the django module has some scraping abilities. It scrapes Google Play search result page, and if the module requires more information, it then calls scraper.

By looking at the design, we hold the threats to the application are: 1) Attackers attacking through the website; 2) Attackers attacking the server; 3) Malicious data injected from Google Play. There are also threats to end users: 4) Attackers may perform man-in-the-middle attack. 5) We have to prevent cross-site attack, and 6) check client side security vulnerabilities, mainly JavaScript.

We assign high priority to 1), 5); medium to 4), 6), low to 2), 3).

\begin{figure}[ht]
\includegraphics[width=\textwidth]{dataFlow.png}
\caption{Data Flow Diagram}
\label{fig:dataFlow}
\end{figure}

Additionally, we also reviewed the data flow in the application, see Figure \ref{fig:dataFlow}. When an user searches our website (Google Play Advanced Search) for some specific apps, the keyword and other search criterion the user specifies enter the Django module. 1) Django sends the keyword to database and get a list of matching apps. The app info may be complete or partial. (Partial means the permission and category info are missing) Then Django filters the result based on the filter the user selected. 2) If the filtered result is less than 200, Django sends the keyword to Google Play Store, asking for potentially more results. Google search page returns app partial info encoded in JavaScript format. 3) Django saves the app partial info to database. 4) If our database now have all the information of apps the user needs, Django just returns the results to the user directly. 5) Otherwise, Django will record the missing apps ID and pass them to Scraper. 6) Scraper goes to Google Play Store to get complete information of the missing apps and save all the new data in database. 7) Finally, Django grabs all the complete information from database and returns them to user.

\begin{enumerate}
    \item  Django sends the keyword to database and get a list of matching apps. The app info may be complete or partial. (Partial means the permission and category info are missing) Then Django filters the result based on the filter the user selected.
    \item If the filtered result is less than 200, Django sends the keyword to Google Play Store, asking for potentially more results. Google search page returns app partial info encoded in JavaScript format. Django decodes them, and saves them to database.
    \item If our database now have all the information of apps the user needs, Django just returns the results to the user directly. 
    \item Otherwise, Django will record the missing apps ID and pass them to Scraper.
    \item Scraper goes to Google Play Store to get complete information of the missing apps and save all the new data in database.
    \item Finally, Django grabs all the complete information from database and returns them to user.
\end{enumerate}




Based on the process of data flow, we found that the most likely security issues - trace malicious input. We try to do some fuzz testings. 

\code{requirements.txt} lists the Python packages not developed by us. In addition, we use SQLite database and some client-side JavaScript libraries. Section \ref{dependency-evaluation} evaluates the security of these dependencies.


\subsection{External Components Evaluation}
\label{dependency-evaluation}
\subsubsection{Python}
The design document states the application is written in Python 3.7, but neither \code{README.md} nor the shebang of the executables, eg. in \code{src/\linebreak[0]GooglePlayAdvancedSearch/scraper/Program.py}, specifies it very clearly. The problem is that another version of Python, which we may not test our project with thoughtfully, might run the code, and have some unexpected interactions with our code, producing bugs or security issues. The better way is to write \code{\#!/usr/bin/env python3.7} instead of \code{\#!/usr/bin/env python3}.

As of the shebang itself, it uses \code{/usr/bin/env}, which is supposed to pick the appropriate program to run the script. Using \code{/usr/bin/env} in shebang makes the script more portable, but attackers may inject their programs to \code{/usr/bin/env} and our project becomes the launcher of attackers' program.


\cite{python37-vulnerability} shows 23 vulnerabilities fixed in patches in Python 3.7, and 2 vulnerabilities unfixed. We found a few issues are clearly relevant to us. In CVE-2020-8315, at Python startup, an attacker's DLL might be loaded on Windows 7. Windows 7 is out of extended support on January 14, 2020.\textsuperscript{\cite{windows7}} Hence, we suggest Google Play Advanced Search to drop support on Windows 7. \cite{bpo-30730} is about Environment variables injection in subprocess on Windows. We use subprocess in the tests module, but we don't pass environment variables. The project might be susceptible to bpo-30458\textsuperscript{\cite{bpo-30458}} because the underlying packages use \code{urllib.urlopen(url)}. However, the URL passed into the function are from Google Play. The URL is unlikely to have a malicious form.

\cite{python37-vulnerability} is not a complete list, though. We also checked other sources. CVE-2019-9636\textsuperscript{\cite{CVE-2019-9636}} warns Improper Handling of Unicode Encoding in \code{urllib\linebreak[0].parse\linebreak[0].urlparse}, which is the function we are using. In \code{Api.search()}, an attacker may give us a crafted URL and cause an SSLError. The code catches the exception, and run \code{urlparse(e.request.url)}, where the vulnerability may be exploited.

Other Python 3.7 vulnerabilities are not immediately relevant to our project because we are not using the affected functions. We should check if the dependencies are using them, but due to time constraint, we didn't do.



\subsubsection{Python Packages}
Project Google Play Advanced Search includes a continuous integration workflow script, located in \code{.github/workflows/pythonapp.yml}. The workflow runs on GitHub Action servers, installs dependencies of the project by reading \code{requirements.txt}, and run automated tests. Since the workflow passes, we are pretty sure that \code{requirements.txt} lists every Python packages the application requires. Next, we will check security issues on the Python packages.

\url{https://app.snyk.io} automatically discovers security vulnerabilities on our project. Figure \ref{fig:snyk} shows the security report. SNYK finds only one high severity issue and one medium severity issue. 

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{snyk.JPG}
\caption{The screenshot of SNYK analysis. We only have one high severity issue and one medium severity issue.}
\label{fig:snyk}
\end{figure}

According to the report, \code{StringAgg(delimiter)} is subject to SQL injection, but our code is not using this function. Other packages used by us don't depend on Django 3.0.2. Therefore we believe we are not susceptible to this issue.

The second Denial of Service vulnerability from Scrapy is irrelevant as well. According to the Scrapy issue\textsuperscript{\cite{scrapy-s3}}, DOS happens when communicating to Amazon S3 server. Since the scraper of Google Play Advanced Search stores scraped data to local database, we are invulnerable to this issue.


To increase confidence, we then manually go over the dependencies.

beautifulsoup4 is listed in \code{requirements.txt}, but we find the project is not using it. People are likely to install the application by running \code{pip install -r requirements.txt}. Thus an unnecessary component is installed to the machine. Although we didn't find major issues of beautifulsoup4 by searching the Internet, installing an unnecessary component brings some security risks anyway.


\cite{django-security-issues} lists other security issues in Django. CVE-2019-19844 is about Potential account hijack via password reset form. Our website doesn't have accounts, so we are immune to this attack. CVE-2019-19118 is about Privilege escalation in the Django admin. However, Google Play Advanced Search doesn't use Django admin site.

pyjson5\textsuperscript{\cite{pyjson5}} doesn't have a dedicated security issues page, but we searched the Internet and didn't find any security issues. However, we notice the project doesn't use this dependency, instead, some Python files import json, which is different than pyjson5. The same as beautifulsoup4, we believe installing an unnecessary component brings some security risks.

CVE-2019-18874 is a Double Free issue in psutil that Google Play Advanced Search uses. Double Free is that a program frees the same memory twice, that may lead to memory leak or alter the execution flow.\textsuperscript{\cite{double-free}} Although the bug was fixed in psutil 5.6.7, because \code{requirements.txt} doesn't specify the version of psutil, the project is vulnerable to this issue. But luckily, psutil is only used in the tests module, only developers or testers might be affected.

\cite{requests-security-vulnerabilities} discloses vulnerabilities in Python package requests. There are no known issues in requests 2.22.0.

The project uses Scrapy 1.8.0. Besides the issue mentioned in Figure \ref{fig:snyk}, Scrapy also had XML External Entity flaw.\textsuperscript{\cite{scrapy-xml}} Nevertheless, Scrapy 1.8.0 doesn't have other known security issues.

Twisted is a package required by Scrapy. In spite of that fact that Twisted had some security issues, for instance Man-in-the-Middle vulnerability and Improper Input Validation\textsuperscript{\cite{cve-twisted}, \cite{snyk-twisted}}, Twisted 19.10.0 that Google Play Advanced Search uses doesn't have known security issues.

urllib3 1.24.3 doesn't have known vulnerabilities although \url{https://www.cvedetails.com} and \url{https://snyk.io} shows some in its earlier versions, including Improper Certificate Validation (fixed in 1.24.2) and CRLF injection (fixed in 1.24.3). Again, the source code of Google Play Advanced Search didn't actually import the package.

Finally, the project requires pytest for automated testing. \code{requirements.\linebreak[0]txt} doesn't specify its version either, which is not a good practice. pytest doesn't have known security issues.


To confirm the project doesn't really need beautifulsoup4, json5, and urllib3, we removed them from \code{requirements.\linebreak[0]txt} and trigger continuous integration. We find urllib3 is a dependency of Twisted, but the other two are not needed. It's good to let Twisted determine the version of urllib3 because the author of Twisted can choose a vulnerability-free version.

\subsubsection{SQLite}
Google Play Advanced Search stores data in SQLite database. According to the README, the required version is 3.24 or higher. Version 3.24 was released on 2020-06-04, and there are 4 vulnerabilities affecting this version.

CVE-2019-16168 may crash an application because a sqlite\_stat1 sz field. The sqlite\_stat1 table is created by the ANALYZE command. However, Google Play Advanced Search doesn't use the ANALYZE command.

CVE-2019-8457 allows attackers to modify some system files but the attacker can't control which files are modified. Nevertheless, it's better to use a higher version of SQLite.

CVE-2018-20506 can run arbitrary SQL statements. This vulnerability is exploitable only if the application uses virtual table. Since Google Play Advanced Search doesn't use virtual table, it's not affected by this issue.

CVE-2018-20346 is a similar issue to CVE-2018-20506. Since Google Play Advanced Search doesn't use virtual table, it's immune to CVE-2018-20346 as well.




\subsection{Code Review}
code review approach
top down? bottom up?
While reviewing our codes, we performed top-down approach where we start with the general framework of the codes and then look deeper into specific functions.

We used Candidate point strategies, searching for \code{StringAgg(delimiter)}, which is subject to SQL injection.



% https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/web_application_security

We are running Django as our framework, so it is good to know about the protection and potential threats provided by Django.
\begin{itemize}
    \item Cross site scripting(XSS). Django's template system protects us against the majority of XSS attacks by escaping specific characters that looks dangerous in HTML. For example the string "<script>" will be turned into "\textcolor{blue}{\&lt}script\textcolor{blue}{\&lt}".
    \item Django provides some CSRF protection by invoking \code{\{\% csrf\_token \%\}} tag into form definition although we don't have any form requests.
    \item SQL injection protection. Django’s querysets are protected from SQL injection since their queries are constructed using query parameterization. A query’s SQL code is defined separately from the query’s parameters. In additional, we have written some raw queries and we need to make sure they are secure from SQL injection (we will talk about it below)
    \item Django can be configured to enforce SSL. With enabling SSL, we can use \code{SECURE\_PROXY\_SSL\_HEADER} to check if the incoming content is secure; \code{SECURE\_SSL\_REDIRECT} to redirect all http to https, (we configure a non-https to https redirection on nginx in our production server instead); and \code{SESSION\_COOKIE\_SECURE} to make sure cookies are only sent over http and \code{SESSION\_COOKIE\_SECURE} to make sure cookies are only sent over https.
\end{itemize}


We looked at the SQL injection possibility on the search box. The handler of the request is at \code{django.web.Api.search()}. We notice the user input keyword is passed into two places, namely \code{DBUtils.AppAccessor.\linebreak[0]searchApps()} and \code{django.web.Api.searchGooglePlay()}. Listing \ref{lst:searchApps} is an extract of \code{django.web.Api.searchGooglePlay()}, where a severe denial of service issue exists.

\begin{lstlisting}[frame=tb, caption=DBUtils.AppAccessor.searchApps(), label=lst:searchApps]
def searchApps(self, namePattern: str) -> List[AppItem]:
	appList = []

	self.__cursor.execute("SELECT id,name,rating,num_reviews,install_fee,inAppPurchases,app_icon FROM App WHERE name LIKE :namePattern", {"namePattern": '%' + namePattern + '%'})
\end{lstlisting}

Neither the searchApps function or the call sites verifies the length of parameter namePattern. Initially on the website, user has to type something to make the search button enabled, which might be the safe guard against searching for an empty keyword, see Figure \ref{fig:website-gray-buton}. However, if the user deletes the keyword, the search button is still enabled. Therefore user is able to search for an empty keyword, and the SQL statement doesn't limit the return rows. If there are many data in database, all data will be returned, and the execution time might be long. It can potentially become a denial of service.


\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{website-gray-button.png}
\caption{Initially the website has a disabled search button, but user can type something then delete them, enabling searching for empty keyword.}
\label{fig:website-gray-buton}
\end{figure}

\subsection{Automated Tests}
Project Google Play Advanced Search comes with a number of automated tests located in the tests module. These are all functional tests and the badge on the README file on the repository confirms the code passes all tests. However, there are no security tests there.



\subsection{Tool Testing Results}
\subsubsection{Nmap for Port Scanning}
We use Nmap to scan the open ports on our server. Currently we have a public ip \textcolor{green}{35.236.119.106} and domain beta.gqqnbig.me

Running Nmap with \code{-p-} flag to scan all 65535 ports on our server.
We find these ports are open:
\begin{center}
    \begin{tabular}{l l l}
        PORT & STATE & SERVICE \\
        22/tcp & open & ssh\\
        80/tcp & open & http\\
        443/tcp & open & https
    \end{tabular}
\end{center}

These are exactly all ports we need to use. We didn't leave any unused port open. Detail output see fig \ref{fig:nmap}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth, frame]{nmap_log.png}
\caption{Nmap Output}
\label{fig:nmap}
\end{figure}

\subsubsection{OWASP ZAP}
ZAP is a open source project developed by OWASP. It can help us to find the some potential security problems of our web server like SQL injection, XSS and many others.
We run zap to attack our website home page and found some Alerts:
\begin{itemize}
    \item Risk: \textcolor{orange}{low}. Cross-Domain JavaScript Source File Inclusion. We are using some third-party javascript libraries. They are:
    \begin{itemize}
        \item jQuery API:\\ \textcolor{blue}{<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>}
        \item A CDN for npm - lodash:\\ \textcolor{blue}{<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"></script>}
        \item A progressive javascript framework - Vue.js:\\ \textcolor{blue}{<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>}
    \end{itemize}
%    \item Risk: \textcolor{orange}{low}. Incomplete or No Cache-control and Pragma HTTP Header Set
%    \item Risk: \textcolor{orange}{low}. X-Content-Type-Options Header Missing on file \code{static/js/vue-click-outside.js} and \code{static/images/question.png}
    \item Risk: \textcolor{blue}{Informational}. Information Disclosure - Suspicious Comments
    \item Risk: \textcolor{blue}{Informational}. Timestamp Disclosure - Unix
\end{itemize}
One way to work around the first alert is by deploying the production mode of above third party javascript libraries to reduce the potential threat if we have more time.

Then we use ZAP to attack our search pages \\(eg. \url{ https://beta.gqqnbig.me/search?q=youtube&pids=33&cids=55,57}) with some permission and category filters.
And we discover more alerts (fig \ref{fig:zap-alerts}).

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth, frame]{zap_alerts.png}
\caption{ZAP Alerts}
\label{fig:zap-alerts}
\end{figure}

In this case, it has a \textcolor{red}{High} risk alert: \code{Remote File Inclusion}. \code{Remote File Include} (RFI) is an attack technique used to exploit "dynamic file include" mechanisms in web applications. When web applications take user input (URL, parameter value, etc.) and pass them into file include commands, the web application might be tricked into including remote files with malicious code.

ZAP suggests a solution: 
Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

Looking back in our code, we do have this kind of validation. There are at most 3 elements \code{q}(keyword), \code{pid}(permission id) and \code{cid}(category id). Everything else will be ignored and perform a normal search. Keyword will be pass to Google play store, pid and cid will be performing a string comparison with apps pids and cids. Looking at our code, unexpected pid and cid will be ignored since there is no such pid/cid we want to exclude. You can how we handle pid and cid in below figure:

\begin{figure}[H]
\begin{subfigure}
\centering
\includegraphics[width=\textwidth]{pidcidhandle.png}
\caption{Pid/Cid Input Handling}
\end{subfigure}
\begin{subfigure}
\centering
\includegraphics[width=\textwidth]{isExcluded.png}
\caption{Function: isExcluded()}
\end{subfigure}
\label{fig:pidcidhandle}
\end{figure}

\subsection{Data Security}
We attempted to use Scuba from Imperva to find the vulnerabilities in our database, but soon we realized SQLite has no concept of user accounts, and instead relies on the file system for all database permissions.

To make our database more secure, we have these following setup in our server/machine:

\begin{itemize}
    \item Only root can change the source code (usually via git pull).
    \begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth, frame]{sourcecodeper.png}
    \end{figure}
    \item We setup a user call "\textcolor{green}{django}" and only "\textcolor{green}{django}" can write to our database (in folder \code{data}).
    \begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth, frame]{databaseper.png}
    \end{figure}
    \item And run the django server using uwsgi with uid 1003 and gid 1004: \code{nohup uwsgi --uid 1003 --gid 1004 --socket /tmp/GooglePlayAdvancedSearch.sock --module web.wsgi --chmod-socket=666 \&> /tmp/django.log \&}
\end{itemize}










\section{Recommendations for future evaluations}

\index{Future evaluations} 
Requirement: If time and resources did not permit you to study the system as fully as you feel was desirable, you should discuss how future efforts to better understand the security of the system should be directed. You should also discuss conditions under which a fresh review might be required, such as the addition of obvious major extensions to the prototype of the project. 

\section{Lessons learned by performing the security evaluation}

\index{Lessons learned}
Requirement: Beyond learning something about the security of the project, we hope you will learn something about designing secure systems, secure coding, and evaluating the security of systems. In this section, discuss what you have learned.  

\section{Work breakdown}

\index{Work breakdown}
Requirement:  Indicate exactly which elements of the report and work required to produce it were performed by each team member. 

Qiqi Gu - responsible for External Components Evaluation.

Shuhua Zhan - responsible for lessons learned section of the report and participated in code review. In the project, participated in element \code{app\_icon}, fixed problem when no results find in google play website and improved the user interface of the website.

\section{Supplementary materials}



\begin{thebibliography}{99}
    \bibitem{django-security-issues} \citeWeb{Archive of security issues}{https://docs.djangoproject.com/en/3.0/releases/security/}{2020-02-25}
    \bibitem{scrapy-s3} \citeWeb{S3FilesStore can use a lot of memory}{https://github.com/scrapy/scrapy/issues/482}{2020-02-25}
    \bibitem{pyjson5} \citeWeb{pyjson5: A Python implementation of the JSON5 data format
}{https://github.com/dpranke/pyjson5}{2020-02-25}
    \bibitem{double-free} \citeWeb{Doubly freeing memory}{https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory}{2020-02-25}
    \bibitem{requests-security-vulnerabilities} \citeWeb{Vulnerability Disclosure}{https://requests.readthedocs.io/en/master/community/vulnerabilities/}{2020-02-25}
    \bibitem{scrapy-xml} \citeWeb{Fixed XXE flaw in sitemap reader}{https://github.com/scrapy/scrapy/pull/676}{2020-02-25}
    \bibitem{snyk-twisted} \citeWeb{twisted vulnerabilities}{https://snyk.io/vuln/pip:twisted}{2020-02-25}
    \bibitem{cve-twisted} \citeWeb{Twisted Vulnerability Statistics}{https://www.cvedetails.com/product/55543/Twistedmatrix-Twisted.html?vendor_id=16756}{2020-02-25}
    \bibitem{windows7} \citeWeb{Windows 7 support ended on January 14, 2020}{https://support.microsoft.com/en-us/help/4057281/windows-7-support-ended-on-january-14-2020}{2020-02-26}
    \bibitem{python37-vulnerability} \citeWeb{Security vulnerabilities - Python Security Vulnerabilities}{https://python-security.readthedocs.io/vulnerabilities.html}{2020-02-26}
    \bibitem{bpo-30458} \citeWeb{[security][CVE-2019-9740][CVE-2019-9947] HTTP Header Injection (follow-up of CVE-2016-5699)}{https://bugs.python.org/issue30458}{2020-02-26}
    \bibitem{bpo-30730} \citeWeb{[security] Injecting environment variable in subprocess on Windows}{https://bugs.python.org/issue30730}{2020-02-26}
    \bibitem{CVE-2019-9636} \citeWeb{CVE-2019-9636}{https://linux.oracle.com/cve/CVE-2019-9636.html}{2020-02-26}
\end{thebibliography}

\index{Supplementary materials}
Requirement: If your analysis produced useful artifacts (such as automated reports, screen shots demonstrating problems, scripts used to test functionality, etc.), include these in appendices, where possible. For things that are not easily embedded in a 
report (such as a video demonstrating how to exploit a security flaw), upload them as separate files when you submit the report. You can also provide links to supplementary materials, but if you do, make sure that the materials are in a location that can be accessed by others, not in a private area. Make sure that your supplementary material section indicates which files are uploaded as part of your report, which links are associated with your report, and what each file or link represents.  
 

\end{document}